#!/usr/bin/env ruby

# Logs the number of queued and active connections on the unicorn/puma socket to
# statsd. There's a cap on the number of queued connections. If we hit it then
# nginx will start serving 504 pages.
#
# There is no visible output, but data is sent to statsd each second.
#
# Props to Tim Lucas for the basic structure:
#
#     https://gist.github.com/toolmantim/0e76d0377bb23974b06f
#
# Usage:
#
#   ./socket-statsd-logger /path/to/unicorn/socket.sock app.unicorn.socket
#

require 'socket'

USAGE = "socket-statsd-logger <path to socket> <metric name>"
METRIC_NAME_REGEXP = /\A[a-z][a-z\.]+[a-z]\Z/

socket_path, metric_name = *ARGV

if socket_path.nil? || metric_name.nil? || !metric_name.match(METRIC_NAME_REGEXP) || !File.exist?(socket_path)
  $stderr.puts USAGE
  exit(1)
end

loop do
  proc_lines = File.read("/proc/net/unix").split("\n")

  # /proc/net/unix lines are of the format:
  # Num       RefCount Protocol Flags    Type St Inode Path
  #
  # A queued connection (02) looks like:
  # 0000000000000000: 00000003 00000000 00000000 0001 02     0 /path/to/socket.sock
  #
  # An active connection (03) looks like:
  # 0000000000000000: 00000003 00000000 00000000 0001 03 132727691 /path/to/socket.sock
  queued = proc_lines.select { |line| line.match(/02\s+\d+\s+#{socket_path}/)}.size
  active = proc_lines.select { |line| line.match(/03\s+\d+\s+#{socket_path}/)}.size

  UDPSocket.new.send("#{metric_name}.queued:#{queued}|g", 0, '127.0.0.1', 8126)
  UDPSocket.new.send("#{metric_name}.active:#{active}|g", 0, '127.0.0.1', 8126)

  sleep(1)
end
