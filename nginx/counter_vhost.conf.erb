upstream <%= upstream_name %> {
  # fail_timeout=0 means we always retry the unicorn master, since it's
  # responsible for restarting workers when they fail.
  server unix:<%= unicorn_socket %> fail_timeout=0;
}

server {
  charset utf-8;

  listen <%= listen_host %>:<%= listen_port %>;
  listen <%= listen_host %>:443 ssl;

  ssl_certificate      certs/<%= domain %>.crt;
  ssl_certificate_key  certs/<%= domain %>.key;
  ssl_session_timeout  5m;
  ssl_ciphers          HIGH:!aNULL:!MD5:!kEDH;

  server_name <%= server_names.join(' ') %>;
  root <%= path / 'public' %>;

  if ($host !~ ^<%= domain.to_s.gsub('.', '\.') %>$) {
    rewrite ^(.*)$ http://<%= domain %>$1 permanent;
  }

  error_page 503 /system/maintenance.html;
  location /system/maintenance.html { return 503; }

  try_files $uri/index.html $uri.html $uri /system/maintenance.html @app;

  # POSTs are intended for the app, not cached pages. We use '=' to let @app set the response code.
  error_page 405 = @app;

  location @app {
    proxy_pass           http://<%= upstream_name %>;
    proxy_redirect       off;

    proxy_buffer_size    64k;
    proxy_buffers        32 16k;
    client_max_body_size 128m;

    proxy_set_header     Host              $host;
    proxy_set_header     X-Real-IP         $remote_addr;
    proxy_set_header     X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header     X-Forwarded-Proto $scheme;
  }
}
